<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"
/>
<title>Enhanced Flappy Bird</title>
<style>
  /* Fullscreen, no scroll */
  html, body {
    margin: 0;
    height: 100svh;        /* iOS friendly viewport height */
    min-height: 100vh;     /* fallback */
    overflow: hidden;      /* kill scrolling */
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    background: linear-gradient(135deg, #ff9a9e 0%, #fad0c4 100%);
    color: #fff;
  }

  /* The game fills the screen; HUD overlays sit on top */
  #stage {
    position: relative;
    width: 100%;
    height: 100%;
    touch-action: manipulation; /* better mobile taps */
  }

  canvas {
    position: absolute;
    inset: 0;       /* fill parent */
    width: 100%;
    height: 100%;
    background: #121418;
  }

  /* HUD (score + buttons) over the canvas, not affecting layout height */
  #hudTop {
    position: absolute;
    top: env(safe-area-inset-top, 8px);
    left: 0; right: 0;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 8px 12px;
    pointer-events: none; /* allow taps to pass through except buttons themselves */
  }

  #scoreboard {
    display: inline-flex;
    gap: 10px;
    font-weight: 700;
    background: rgba(0,0,0,0.25);
    padding: 6px 10px;
    border-radius: 12px;
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.35);
    pointer-events: auto;
  }
  #score::before { content: "‚ù§Ô∏è "; }
  #best::before  { content: "üíñ "; }

  #buttons {
    display: inline-flex;
    gap: 8px;
    pointer-events: auto;
  }
  #buttons button {
    border: 0;
    padding: 8px 12px;
    border-radius: 10px;
    font-weight: 700;
    color: #fff;
    background: linear-gradient(180deg, #ff758c 0%, #ff7eb3 100%);
    box-shadow: 0 3px 8px rgba(0,0,0,0.25);
  }

  /* Bottom instructions overlay */
  #hint {
    position: absolute;
    bottom: calc(env(safe-area-inset-bottom, 8px));
    left: 0; right: 0;
    text-align: center;
    color: #f0e6f6;
    font-size: 14px;
    opacity: 0.95;
    pointer-events: none;
  }
</style>
</head>
<body>
  <div id="stage">
    <canvas id="game"></canvas>

    <div id="hudTop">
      <div id="scoreboard">
        <span id="score">Score: 0</span>
        <span id="best">Best: 0</span>
      </div>
      <div id="buttons">
        <button id="pauseBtn">Pause</button>
        <button id="restartBtn">Restart</button>
      </div>
    </div>

    <div id="hint">Tap anywhere to flap ‚Ä¢ P = pause ‚Ä¢ Enter = restart</div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const bestEl = document.getElementById('best');
  const pauseBtn = document.getElementById('pauseBtn');
  const restartBtn = document.getElementById('restartBtn');
  const hint = document.getElementById('hint');

  /* -------- Responsive canvas (no scroll) -------- */
  function resizeCanvas() {
    // Match backing store to CSS size for crispness without overflow
    const w = Math.floor(window.innerWidth);
    const h = Math.floor(window.innerHeight);
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    canvas.width = w;     // keep DPR 1 for performance on phones
    canvas.height = h;
    BIRD_X = Math.round(canvas.width * 0.25);  // bird sits ~25% from left
  }
  window.addEventListener('resize', resizeCanvas);
  window.addEventListener('orientationchange', () => setTimeout(resizeCanvas, 150));

  /* -------- Game constants (tuned a bit faster on mobile) -------- */
  let BIRD_X = 100;                // updated by resizeCanvas()
  const BIRD_RADIUS = 18;

  // Slightly faster than previous build (but still friendly)
  const GRAVITY = 0.22;
  const FLAP_STRENGTH = -5.6;
  const MAX_FALL_SPEED = 5.2;

  const PIPE_WIDTH = 70;
  const BASE_PIPE_GAP = 200;
  const MIN_GAP = 160;

  const PIPE_INTERVAL = 170;     // spawn a bit sooner than before
  const BASE_SPEED = 1.25;       // faster pipes
  const SPEED_INCREASE = 0.018;  // gentle ramp

  const CUTE_MESSAGES = [
    "You're amazing, my love!",
    "You're doing great, sweetheart!",
    "So proud of you, darling!",
    "You make my heart soar!",
    "You're my favorite player!",
    "Keep flying, cutie!",
    "Love you! ‚ù§Ô∏è"
  ];

  /* -------- State -------- */
  let birdY, birdVel, pipes, pipeTimer, score, best, speed, state;
  let currentMessage = null, messageEndTime = 0;

  best = parseInt(localStorage.getItem('flappyBest')) || 0;
  bestEl.textContent = `Best: ${best}`;

  function resetGame() {
    birdY = canvas.height / 2;
    birdVel = 0;
    pipes = [];
    pipeTimer = 0;
    score = 0;
    speed = BASE_SPEED;
    currentMessage = null;
    messageEndTime = 0;
    state = 'start';
    updateScoreboard();
    hint.style.display = '';
  }

  function updateScoreboard() {
    scoreEl.textContent = `Score: ${score}`;
    bestEl.textContent = `Best: ${best}`;
  }

  function spawnPipe() {
    const gap = Math.max(MIN_GAP, BASE_PIPE_GAP - score * 2);
    const gapY = Math.random() * (canvas.height - gap - 100) + 50;
    pipes.push({ x: canvas.width, gapY, gapHeight: gap, passed: false });
  }

  function flap() {
    if (state === 'start') {
      state = 'running';
      hint.style.display = 'none';
    }
    if (state === 'running') {
      birdVel = FLAP_STRENGTH;
    } else if (state === 'gameover') {
      resetGame();
    }
  }

  function togglePause() {
    if (state === 'running') { state = 'paused'; pauseBtn.textContent = 'Resume'; }
    else if (state === 'paused') { state = 'running'; pauseBtn.textContent = 'Pause'; }
  }

  function update() {
    if (state !== 'running') return;

    birdVel += GRAVITY;
    if (birdVel > MAX_FALL_SPEED) birdVel = MAX_FALL_SPEED;
    birdY += birdVel;

    // Pipes
    pipeTimer++;
    if (pipeTimer >= PIPE_INTERVAL) { spawnPipe(); pipeTimer = 0; }
    for (let i = 0; i < pipes.length; i++) {
      const p = pipes[i];
      p.x -= speed;
      if (!p.passed && p.x + PIPE_WIDTH < BIRD_X) {
        p.passed = true;
        score++;
        speed += SPEED_INCREASE;
        if (score > best) { best = score; localStorage.setItem('flappyBest', best); }
        updateScoreboard();

        // Milestone messages every 3 points
        if (score % 3 === 0) {
          const idx = ((score / 3) - 1) % CUTE_MESSAGES.length;
          currentMessage = CUTE_MESSAGES[idx];
          messageEndTime = performance.now() + 1800; // ~1.8s
        }
      }
    }
    while (pipes.length && pipes[0].x + PIPE_WIDTH < 0) pipes.shift();

    // Collisions
    if (birdY + BIRD_RADIUS > canvas.height || birdY - BIRD_RADIUS < 0) state = 'gameover';
    pipes.forEach(p => {
      if (BIRD_X + BIRD_RADIUS > p.x && BIRD_X - BIRD_RADIUS < p.x + PIPE_WIDTH) {
        if (birdY - BIRD_RADIUS < p.gapY || birdY + BIRD_RADIUS > p.gapY + p.gapHeight) state = 'gameover';
      }
    });

    if (state === 'gameover') {
      currentMessage = null;
      messageEndTime = 0;
      hint.textContent = `Game Over! Score: ${score}. Tap to restart.`;
      hint.style.display = '';
      pauseBtn.textContent = 'Pause';
    }
  }

  function draw() {
    ctx.fillStyle = '#121418';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Pipes
    pipes.forEach(p => {
      ctx.fillStyle = '#34c77a';
      ctx.fillRect(p.x, 0,     PIPE_WIDTH, p.gapY);
      ctx.fillRect(p.x, p.gapY + p.gapHeight, PIPE_WIDTH, canvas.height - (p.gapY + p.gapHeight));
    });

    // Bird
    ctx.fillStyle = '#ffd966';
    ctx.beginPath();
    ctx.arc(BIRD_X, birdY, BIRD_RADIUS, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#1c2a28';
    ctx.beginPath();
    ctx.arc(BIRD_X + 6, birdY - 4, 4, 0, Math.PI * 2);
    ctx.fill();

    // Inline milestone message
    if (state === 'running' && currentMessage && performance.now() < messageEndTime) {
      ctx.save();
      ctx.textAlign = 'center';
      ctx.font = '20px Arial';
      ctx.fillStyle = 'rgba(247, 197, 120, 0.92)';
      ctx.fillText(currentMessage, canvas.width / 2, 46);
      ctx.restore();
    } else if (currentMessage && performance.now() >= messageEndTime) {
      currentMessage = null;
    }

    // Start / Paused overlays
    if (state === 'start') {
      ctx.fillStyle = '#e1e1e1';
      ctx.textAlign = 'center';
      ctx.font = '24px Arial';
      ctx.fillText('Tap to start', canvas.width / 2, canvas.height / 2 - 26);
      ctx.font = '16px Arial';
      ctx.fillText('Press space/ArrowUp to flap', canvas.width / 2, canvas.height / 2);
    } else if (state === 'paused') {
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';
      ctx.font = '26px Arial';
      ctx.fillText('Paused', canvas.width/2, canvas.height/2);
    }
  }

  function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
  }

  /* Input */
  document.addEventListener('keydown', (e) => {
    if (e.key === ' ' || e.key === 'ArrowUp') { e.preventDefault(); flap(); }
    else if (e.key.toLowerCase() === 'p') togglePause();
    else if (e.key === 'Enter' && state === 'gameover') resetGame();
  });
  canvas.addEventListener('click', flap);
  canvas.addEventListener('touchstart', (e) => { e.preventDefault(); flap(); }, { passive: false });

  pauseBtn.addEventListener('click', () => {
    if (state === 'running' || state === 'paused') togglePause();
  });
  restartBtn.addEventListener('click', () => resetGame());

  /* Boot */
  resizeCanvas();
  resetGame();
  loop();
})();
</script>
</body>
</html>